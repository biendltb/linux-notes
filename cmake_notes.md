
## CMake
#### Header
```cmake
cmake_minimum_required(VERSION 3.0)

# set project name and version
project(<project_name> VERSION 1.0)

# specify the C++ standard: 11 or 17
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
```

#### Find a library
```cmake
find_package(PackageName 2.0 REQUIRED)
if(NOT PackageName_FOUND)
    message(FATAL_ERROR "PackageName not found")
endif()
```
* Library variables (e.g. `<PackageName>_LIBS`, `<PackageName>_INCLUDE_DIR` will be set after the library found)
* `<PackageName>_FOUND` indicates if the package found
* Version `2.0` speficied could match 2.x, use `EXAC` to find the packlage in the exact version
* Use `REQUIRED` to to show error if package not found and `QUIET` to ignore

#### Build a library
Note: Set  `PRIVATE` or `PUBLIC` for `target_include_directories` to allow/disallow other targets (e.g. in a subdirectories CMake) to access the include files when they use that library.

```cmake
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)

# add library: add our own code so that the executable could use when they are compiled
add_library(${PROJECT_NAME} SHARED
    src/abc/def.cc
    ...
)

target_link_libraries(${PROJECT_NAME}
    ${lib1_LIBS}
    ${lib2_LIBRARIES}
    ${PROJECT_SOURCE_DIR}/Thirdparty/<LibraryName>/lib/lib<LibraryName>.so
)

target_include_directories(${PROJECT_NAME} <PRIVATE|Public>
${PROJECT_SOURCE_DIR}
${PROJECT_SOURCE_DIR}/include
${LibAbc_INCLUDE_DIR}
${LibXyz_INCLUDE_DIRS}
)

```
#### Build an executable
```cmake
# specified place to save executable file
# unless executable file will be saved to build by default
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/abc/def)

# Specify source files to build
set(SOURCES
    ${PROJECT_SOURCE_DIR}/abc/xyz.cc
    path/to/source/file.cc
}

# add executable for demo, test, examples, etc.
add_executable(<executable_name>
    path/to/executable.cc
    ${SOURCES}
)
target_include_directories(<executable_name> ${PROJECT_SOURCE_DIR}/include)
target_link_libraries(<executable_name> ${PROJECT_NAME} ${<PackageName_LIBS>})
```
#### GLOB
Instead of listing all the source files as shown above, GLOB makes listing source file easier.
```cmake
file(GLOB SOURCES
    "abc/*.cc"
    "abc/def/*.cc"
)
# message(STATUS ${SOURCES}
```

#### Main CMakeLists.txt
Multiple CMakeLists.txt of different modules could be build at the same time. All we need to do is adding sub-directories which contains CMakeLists.txt to the main CMakeLists.txt
```cmake
# Main CMakeLists.txt
cmake_minimum_required(VERSION 3.0)

# set project name and version
project(<project_name> VERSION 1.0)

# specify the C++ standard: 11 or 17
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

add_subdirectory(/modules/abc/)
```

#### Simple `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.0)

# set project name and version
project(<project_name> VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)


# ======================= FIND LIBRARIES TO USE IN LATER STEPS
# find a package with version, `<PackageName>_FOUND` indicates if the package found
# Note: 2.0 could match 2.x, use `EXACT` to find the package in the exact version
# Use `REQUIRED` to show error if package not found, use `QUIET` to ignore
# library variables (e.g. `lib1_LIBS`, `lib1_INCLUDE_DIR` will be set after the library found)
find_package(PackageName 2.0 REQUIRED)
if(NOT PackageName_FOUND)
    message(FATAL_ERROR "PackageName not found")
endif()

# ======================= BUILD A LIBRARY
# specify place to store the `.so` library of our project
# output library name: `lib<project_name>.so`
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)

# add library: add our own code so that the executable could use when they are compiled
add_library(${PROJECT_NAME} SHARED
    src/abc/def.cc
    ...
)

# link libraries needed to build the project
# the first argument is the name of target lib/executable
# the variable name of included libraries could be generated by find_package or specified if the library is included in the project
target_link_libraries(${PROJECT_NAME}
    ${lib1_LIBS}
    ${lib2_LIBRARIES}
    ${PROJECT_SOURCE_DIR}/Thirdparty/<LibraryName>/lib/lib<LibraryName>.so
)

target_include_directories(${PROJECT_NAME} PUBLIC
${PROJECT_SOURCE_DIR}
${PROJECT_SOURCE_DIR}/include
${LibAbc_INCLUDE_DIR}
${LibXyz_INCLUDE_DIRS}
)

# ======================= BUILD AN EXECUTABLE
# specified place to save executable file
# unless executable file will be saved to build by default
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/abc/def)

# add executable for demo, test, examples, etc.
add_executable(<executable_name>
    path/to/executable.cc
    ${SOURCES}
)
target_include_directories(<executable_name> PUBLIC ${PROJECT_SOURCE_DIR}/include)
target_link_libraries(<executable_name> ${PROJECT_NAME})

```

### Other useful commands
#### Build type and CMake generator expression
`CMAKE_BUILD_TYPE` could be set when running the cmake command:
```bash
cmake -DCMAKE_BUILD_TYPE=Debug -DPERFORMANCE=ON -DVISUALIZATION=ON ../ 
```
The build type could be check as:
```bash
if (${CMAKE_BUILD_TYPE} MATCHES "Debug")
    find_package( Pangolin REQUIRED )
    message ( $<CMAKE_BUILD_TYPE>)
endif (${CMAKE_BUILD_TYPE} MATCHES "Debug")
```

When deciding the code/library which only for Debug/Release, we could use generator expression which only be run in build step.

https://cmake.org/cmake/help/v3.11/manual/cmake-generator-expressions.7.html

```bash
#NOTE: NO SPACES, NO DOUBLE QUOTES IN "Debug"
target_include_directories(${LIB} PUBLIC
    # ${Pangolin_INCLUDE_DIRS}
    $<$<STREQUAL:${CMAKE_BUILD_TYPE},Debug>:${Pangolin_INCLUDE_DIRS}>
)

target_link_libraries(${LIB}
    # ${Pangolin_LIBRARIES}
    $<$<STREQUAL:${CMAKE_BUILD_TYPE},Debug>:${Pangolin_LIBRARIES}>
)

```

#### Inject configure and build environment variables to source file
There are some situations that some information that exists in the build time (e.g. versions, source paths, configurations) is needed to be injected to source file. This could be done with the `configure_file` keyword of CMake.
First in the config file, we could use cmake variables as in CMakeLists.txt file, for example:
```cpp
#define VERSION "${MAJOR}.${MINOR}.${PATCH}-${VERSION_SUFFIX}"
```
And in CMakeLists.txt, those variables are assigned and fill to the source file and copy to the destination by:

```cmake
set(MAJOR 1)
set(MINOR 0)
set(PATCH 0)
set(VERSION_SUFFIX "a1")
configure_file(configure.h.in ${CMAKE_CURRENT_BINARY_DIR}/configure.h)
```



